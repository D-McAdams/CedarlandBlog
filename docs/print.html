<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cedarland Blog</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About</a></li><li class="chapter-item expanded "><a href="design/introduction/content.html"><strong aria-hidden="true">1.</strong> Design History</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design/why-cedar/content.html"><strong aria-hidden="true">1.1.</strong> Why was Cedar created?</a></li><li class="chapter-item expanded "><a href="design/why-no-regex/content.html"><strong aria-hidden="true">1.2.</strong> Why doesn't Cedar have regexes and string operators?</a></li><li class="chapter-item expanded "><a href="design/why-no-float/content.html"><strong aria-hidden="true">1.3.</strong> Why doesn't Cedar support floating point numbers?</a></li><li class="chapter-item expanded "><a href="design/why-ignore-errors/content.html"><strong aria-hidden="true">1.4.</strong> Why does Cedar ignore policies that error?</a></li><li class="chapter-item expanded "><a href="design/why-semicolon/content.html"><strong aria-hidden="true">1.5.</strong> Why do Cedar policies end with a semi-colon?</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cedarland Blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="its-not-about-the-tree"><a class="header" href="#its-not-about-the-tree">It's not about the tree..</a></h2>
<html>
<table style="border-collapse: collapse; padding: 0; margin: 0;">
        <tr>
            <td style="border: none; width: 25%; vertical-align: top">
                <img src="./img/IllustratedCedarTree.jpeg" alt="Your Image" style="display: block; width: 100%; height: auto;">
            </td>
            <td style="border: none; vertical-align: top">
	        <p>
		This is a blog about the <strong><a href="https://www.cedarpolicy.com/">Cedar Policy Language</a></strong>.
                <p>
                I'm Darin McAdams, Sr. Principal Engineer in Amazon Web Services and part of the team that originally built Cedar.
		</p>
		<p>
		This is my personal blog covering Cedar topics such as the language design, usage patterns, and various other curiosities. All opinions are my own. All intelligent statements probably come from my teammates.
                </p>
            </td>
        </tr>
</table>
</html>
<h2 id="recent-posts"><a class="header" href="#recent-posts">Recent Posts</a></h2>
<ul>
<li><a href="./design/why-cedar/content.html">June 12, 2023 - Why was Cedar created?</a></li>
<li><a href="./design/why-no-regex/content.html">June 25, 2023 - Why doesn't Cedar have regexes or string formatting operators?</a></li>
<li><a href="./design/why-no-float/content.html">June 25, 2023 - Why doesn't Cedar support floating-point numbers?</a></li>
<li><a href="./design/why-ignore-errors/content.html">June 25, 2023 - Why does Cedar ignore policies that error?</a></li>
<li><a href="./design/why-semicolon/content.html">June 25, 2023 - Why do Cedar policies end with a semi-colon?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-history"><a class="header" href="#design-history">Design History</a></h1>
<p>These blog posts share details about the language design and answer frequently asked questions.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="why-was-cedar-created"><a class="header" href="#why-was-cedar-created">Why was Cedar created?</a></h2>
<p>When Cedar launched in 2022, one of the common questions we received was <em>&quot;Why?&quot;</em>. After all, there was no shortage of existing authorization grammars at the time. Creating another was not the initial intent. Yet, as we evaluated options, we struggled to find one that met our needs. This eventually informed the decision to create a new language and established its guiding principles.</p>
<p>To frame the context, Cedar was originally developed in AWS to support services such as <a href="https://aws.amazon.com/verified-permissions/">Amazon Verified Permissions</a> and <a href="https://aws.amazon.com/verified-access/">AWS Verified Access</a>. Like most cloud offerings, our services typically share common characteristics which we wanted to hold true for authorization solutions, as well. Cloud services tend to be multi-tenant and seek to provide a high quality of service for all customers. If an individual authorization rule can take excessive time to run, or consume excessive system resources, this works against the quality of service goals for customers and was a behavior we sought to avoid in an authorization grammar. Cloud services also run at high scale and callers want them to behave flawlessly, making efficiency and correctness an important consideration. In terms of security, our authorization rules would be written by external customers and evaluated by the cloud service, making policies a form of untrusted code that needed to be evaluated safely. Lastly, we wanted the policy language to be understandable by a broad range of customers, and to allow for robust analysis of existing rules and the potential impacts of changing them.</p>
<p>All these criteria - performance, correctness, safety, analyzability – serviced as guideposts to the design of Cedar. While not all users will find themselves operating services at the same scale, we believe the criteria this demands are broadly beneficial in all domains. </p>
<p>In discrete terms, Cedar was designed to provide the following properties.</p>
<h3 id="bounded-latencies"><a class="header" href="#bounded-latencies">Bounded Latencies</a></h3>
<p>Cedar is designed to make sub-millisecond authorization decisions for typical situations, regardless of the skill level of the policy author. No Cedar operators can result in blocking operations, non-terminating loops, or severe performance degradations. </p>
<h3 id="no-sandboxing-required"><a class="header" href="#no-sandboxing-required">No Sandboxing Required</a></h3>
<p>In a high TPS system, the overhead of sandboxing every authorization decision would be impractical. Cedar policies are designed to be safely evaluated without security sandboxing, even if written by untrusted actors. Cedar contains no file system accessors, system calls, or networking operators.</p>
<h3 id="default-deny-and-order-independent-evaluation"><a class="header" href="#default-deny-and-order-independent-evaluation">Default-Deny and Order-Independent Evaluation</a></h3>
<p>The Cedar evaluator will deny by default unless there exists at last one matching permit statement and no matching forbid statement. This evaluation criteria is designed to be simple, safe, and robust, and is not reliant on policy evaluation order. </p>
<p>Alternative authorization systems have sometimes offered more flexibility over the evaluation logic, including custom rules on policy precedence and override behavior. In recent years, there has been a general industry recognition that complexity in the human/technology interface is often a primary origin of security risk. In other words, people make mistakes, people get confused, and people click buttons to make something work without understanding why. Cedar adheres to a philosophy that a single safe-by-default evaluation mode is a preferred approach. </p>
<h3 id="ergonomic-syntax"><a class="header" href="#ergonomic-syntax">Ergonomic Syntax</a></h3>
<p>Cedar is designed to be understandable by a broad audience. One of the design goals was that anyone should be able to read a Cedar policy and generally understand what it does without having any prior familiarity with the Cedar language.</p>
<p>In terms of writing policies, our design goal was that anyone with a technical skillset on par with writing SQL statements should be able to author Cedar policies. In addition, by including schema files, we wanted to make it possible to validate policies for correctness and to open the door to advanced editing capabilities such as autocompletion and more.</p>
<h3 id="support-for-various-authorization-approaches"><a class="header" href="#support-for-various-authorization-approaches">Support For Various Authorization Approaches</a></h3>
<p>A number of well-known authorization patterns have developed over time, including RBAC, ABAC, and newer approaches such as ReBAC. All are useful in various circumstances and we didn't want to preclude customers from choosing an approach that worked best for them. Cedar is designed to support all well-known authorization patterns, and even allows them to be used in combination.</p>
<h3 id="verification-guided-development"><a class="header" href="#verification-guided-development">Verification-guided Development</a></h3>
<p>In recognition of the important security role that Cedar plays, we wanted confidence that authorization decisions would be correct. To achieve this, we followed an approach we call <em>verification-guided development</em>. This approach uses automated reasoning and random differential testing to provide a high degree of trust in the implementation. My teammate Mike Hicks describes this approach in more detail in his <a href="https://www.amazon.science/blog/how-we-built-cedar-with-automated-reasoning-and-differential-testing">blog post</a>.</p>
<h3 id="amenable-to-automated-analysis"><a class="header" href="#amenable-to-automated-analysis">Amenable to Automated Analysis</a></h3>
<p>Writing a policy is often the easiest part of an authorization solution. The more difficult part can be understanding what the current policies do, predicting the impact of a change, and proving to auditors that policies are correct.</p>
<p>Cedar was designed to support <a href="https://en.wikipedia.org/wiki/Automated_reasoning">automated reasoning</a> over a body of policies in order to enable provable assertions about system behavior. </p>
<p>Creating a language that is amenable to automated reasoning requires careful decision making about the supported data types and operators, as the technique relies on <a href="https://en.wikipedia.org/wiki/Symbolic_execution">symbolic evaluation</a> that considers every possible path through the code. The challenge is to keep paths sufficiently bounded so that reasoning over language statements remains tractable. For example, unbounded loops lead to an infinite, intractable number of possible paths. Even something as simple as choosing between sets vs. lists can have ramifications, as lists require the reasoning tools to consider the order that something appears and  whether there can be more than one occurrence in the list, whereas sets do not. As a result, sets are more tractable for analysis. (Cedar only supports sets.)</p>
<h3 id="scalable-to-large-numbers-of-policies"><a class="header" href="#scalable-to-large-numbers-of-policies">Scalable to Large Numbers of Policies</a></h3>
<p>When a system contains only a small number of authorization policies, deciding which policies to include in an authorization evaluation is a trivial matter; you can simply evaluate them all. However, as a system scales up to hundreds, thousands, or even millions of policies in a multi-tenant system, it is no longer practical to load all policies into memory to make an individual authorization decision. A more finely-tuned mechanism is required to determine which policy statements are relevant to a particular authorization query and which can be safely ignored. Cedar was designed to support this capability with a well-defined policy structure that includes a header designating the scope of the principals and resources to which a policy applies. </p>
<h2 id="striking-the-right-balance"><a class="header" href="#striking-the-right-balance">Striking the Right Balance</a></h2>
<p>All these goals presented constraints that needed to be weighed against solving real-world authorization scenarios. After all, a robust authorization solution that can solve no real-world problems has a slim chance of adoption. Cedar's aim was to strike that balance, residing in a design space that is flexible enough for most scenarios, but structured enough to deliver the other goals. </p>
<p>For audiences interested in learning more, my teammate Emina Torlak presented this 23 minute session which dives deeper into the language design and syntactical choices of Cedar.</p>
<p><a href="https://www.youtube.com/watch?v=k6pPcnLuOXY&amp;t=1779s">https://www.youtube.com/watch?v=k6pPcnLuOXY&amp;t=1779s</a></p>
<p>
  <a href="https://www.youtube.com/watch?v=k6pPcnLuOXY&t=1779s" title="Cedar Presentation">
    <img src="design/why-cedar/./presentation-screenshot.png" alt="Screenshot of Cedar Presentation"/>
  </a>
</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="why-doesnt-cedar-have-regexes-or-string-formatting-operators"><a class="header" href="#why-doesnt-cedar-have-regexes-or-string-formatting-operators">Why doesn't Cedar have regexes or string formatting operators?</a></h2>
<p>Cedar's design methodology is underpinned by a philosophy of safety, as described in <a href="design/why-no-regex/../why-cedar/content.html">&quot;Why was Cedar created?&quot;</a>. Safety considerations are wide-ranging and can include factors such as preventing excessive resource consumption, preserving the ability to analyze polices for correctness, or simply guiding policy authors away from common logical mistakes.</p>
<p>Regular expressions and string formatting operators were intentionally omitted from the language because they work against these safety goals. This blog post describes why they can be dangerous and alternative approaches to writing policies without them.</p>
<h3 id="these-operators-are-error-prone-and-impolite-to-policy-authors"><a class="header" href="#these-operators-are-error-prone-and-impolite-to-policy-authors">These operators are error-prone (and impolite to policy authors)</a></h3>
<p>As an example, consider an authorization policy that wants to make decisions based on a URL and query string received by a web application. A naïve way to do this is to pass the entire URL as a string into the context of the policy evaluator:</p>
<pre><code>&quot;context&quot;: {
    &quot;url&quot;: &quot;https://example.com/path?queryParam1=hello&amp;queryParam2=world&quot;
}
</code></pre>
<p>If the policy author wanted to make decisions based on subcomponents of the URL, such as the host name or particular query parameters, the policy author might need to apply regexes to match the subcomponents.</p>
<pre><code>forbid (principal, action, resource)
unless {
    context.url.matches(&quot;^http(s?)://example.com/&quot;)
};
</code></pre>
<p>They would also need to use string formatting operators to normalize the values appropriately. Normalization is important because fields such as <code>host</code> are case-insensitive, and a malicious actor could potentially subvert an authorization rule by sending an HTTP request with different capitalization.</p>
<pre><code>forbid (principal, action, resource) 
unless {
    //Lowercase the hostname before matching, otherwise a caller
    //could bypass this policy by sending https://EXAMPLE.COM/
    context.url.toLowerCase.matches(&quot;^http(s?)://example.com/&quot;)
};
</code></pre>
<p>But, how should policy authors handle the query parameters? Are those case-insensitive or not? Do they have other normalization requirements? And, if so, how would the policy author know? These are application-specific details.</p>
<pre><code>forbid (principal, action, resource)
unless {
    // Should this also match &quot;HELLO&quot; or &quot;Hello&quot;?
    context.url.matches(&quot;[&amp;\?]queryParam1=hello[&amp;\b]&quot;)
};
</code></pre>
<p>Shifting this burden onto policy authors who may not deeply understand the application details is error-prone. It is also impolite and wasteful, since many different policy authors are bearing the burden of implementing the potentially complex logic. Cedar's philosophy is that application owners should strive to format and normalize data before passing it into the authorization evaluator. This keeps the logic with the owners who have the most domain expertise, and centralizes it in one location so it can benefit all policy authors.</p>
<p>From this perspective, the URL information could be passed into the evaluator in a pre-normalized format such as the following:</p>
<pre><code>&quot;context&quot;: {
    &quot;url&quot;: {
        &quot;transport&quot;: &quot;https&quot;,
        &quot;host&quot;: &quot;example.com&quot;,
        &quot;path&quot;: &quot;/path&quot;,
        &quot;queryParams&quot; {
            &quot;queryParam1&quot;: &quot;hello&quot;,
            &quot;queryParam2&quot;: &quot;world&quot;
        }
    }
}
</code></pre>
<p>And a policy author could express rules such as the following:</p>
<pre><code>forbid (principal, action, resource)
unless {
    context.url.host == &quot;example.com&quot;
};
</code></pre>
<p>Another reason that regular expressions are error-prone is because of human error. To provide a real life example shared with me by a teammate, a policy author (in a non-Cedar system) wanted to write a rule that allowed anyone in the <em>&quot;admin&quot;</em> group to have super-administrator privileges in an application. This was done by examining a user's list of groups and testing against the regex <code>/admin/</code>. The mistake was not including the word-boundary conditions in the regex, such that this rule accidentally matched the group <em>&quot;administrative-assistants&quot;</em> and theoretically, I guess, the <em>&quot;badminton-club&quot;</em>. The administrative assistants discovered this access and found it quite useful in getting their job done.</p>
<p>Regular expressions and string formatting operations are powerful features that are useful in many programming environments. However, in authorization rules that protect access to critical resources, Cedar takes the perspective that simple, safe, auditable rules are preferrable over unbounded flexibility.</p>
<h3 id="these-operators-are-subject-to-runtime-risks"><a class="header" href="#these-operators-are-subject-to-runtime-risks">These operators are subject to runtime risks</a></h3>
<p>Regexes and string formatting operations carry runtime risks, as well. Regexes are subject to poor performance characteristics, including worst-case scenarios such as <a href="https://www.google.com/search?q=regex+catastrophic+backtracking+ddos">catastrophic backtracking</a>. String formatting operations can also be abused. To provide an example, consider an operator that concatenates two strings and emits a new string.</p>
<pre><code>newString = concat(string1,string2)
</code></pre>
<p>Presuming the input strings are well-bounded in size, this operator is safe when used once. But, what happens if string concatenations are nested?</p>
<pre><code>concat( concat(x,x), concat(x,x))
</code></pre>
<p>If <code>x=&quot;hello&quot;</code>, this concatenates the string <code>&quot;hello&quot;</code> repeatedly</p>
<pre><code>hello
hellohelllo
hellohellohellohello
</code></pre>
<p>A malicious policy author could push this to an extreme:</p>
<pre><code>concat( concat( concat( concat( concat( concat(x,x), concat(x,x)), concat(concat(x,x), concat(x,x))), concat( concat( concat(x,x), concat(x,x)), concat(concat(x,x), concat(x,x)))), concat( concat( concat( concat(x,x), concat(x,x)), concat(concat(x,x), concat(x,x))), concat( concat( concat(x,x), concat(x,x)), concat(concat(x,x), concat(x,x))))), concat( concat( concat( concat( concat(x,x), concat(x,x)), concat(concat(x,x), concat(x,x))), concat( concat( concat(x,x), concat(x,x)), concat(concat(x,x), concat(x,x)))), concat( concat( concat( concat(x,x), concat(x,x)), concat(concat(x,x), concat(x,x))), concat( concat( concat(x,x), concat(x,x)), concat(concat(x,x), concat(x,x))))))
</code></pre>
<p>Due to the power of exponential growth, it would take only 40 repetitions of concatenation to transform the word &quot;hello&quot; into a 5 terabyte string that exceeds the available memory on nearly all classes of modern, general purpose web servers. To provide bounded runtime latencies, an authorization engine would need to guard against excessive memory allocation and fail at runtime. This requires a degree of guesswork about how much memory is &quot;too much&quot;, with a risk of that choice being either too high or too low for someone's legitimate situation.</p>
<h3 id="these-operators-are-not-analyzable"><a class="header" href="#these-operators-are-not-analyzable">These operators are not analyzable</a></h3>
<p>As described in <a href="design/why-no-regex/../why-cedar/content.html">Why was Cedar created?</a>, the language was built using verification-guided development and designed for automated reasoning. These techniques provide two benefits: they give a high-degree of confidence that Cedar is implemented correctly (i.e. bug free), and they also allow analyses in order to give you confidence that the policies you write in Cedar are correct.</p>
<p>Regexes and many string formatting operators are not amenable to these formal reasoning techniques. As a result, these operators simultaneously increase the likelihood of end-user mistakes when writing policies, while at the same time lessening Cedar's ability to alert users of these mistakes. </p>
<h3 id="alternative-approaches"><a class="header" href="#alternative-approaches">Alternative Approaches</a></h3>
<p>As mentioned earlier, the most common approach is to pre-format data before passing it into the authorization evaluator, thereby freeing policy authors from the need for regular expressions and string formatting operators.</p>
<p>When this is insufficient, the Cedar team is interested in hearing the requirements. (You can reach the community on the <a href="https://communityinviter.com/apps/cedar-policy/cedar-policy-language">Cedar Slack channel</a>.) Although Cedar is strict in terms of safety, it is also pragmatically motivated to solve real-world scenarios. Quite often, alternative approaches can be found that address requirements while adhering to safety goals. For example, <strong>Cedar includes a <code>like</code> operator with the wildcard character <code>*</code></strong>, which solves many situations that would otherwise require regexes. Cedar also supports extended datatypes for fields such as <a href="https://docs.cedarpolicy.com/syntax-datatypes.html#ipaddr">IP Address</a>, with built in validation and helpful operators that can be used in policy expressions. Additional extended datatypes can be introduced if they have broad applicability.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="why-doesnt-cedar-support-floating-point-numbers"><a class="header" href="#why-doesnt-cedar-support-floating-point-numbers">Why doesn't Cedar support floating point numbers?</a></h2>
<p>Sometimes, it's necessary to write an authorization rule against numbers that contain decimal parts. For example, you may want to check if a currency field is greater than <code>&quot;1.99&quot;</code>, or compare the output from an ML-based risk scoring system which emits values like <code>&quot;0.9234&quot;</code>. <strong>Cedar supports this using the <a href="https://docs.cedarpolicy.com/syntax-datatypes.html#decimal">Decimal type</a></strong> with a fixed precision, where the maximum number of digits after the decimal is four. </p>
<p>In many other programming environments, there is an alternative representation of numbers known as <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">floating-point</a> which allows for bigger or smaller values with different degrees of precision. For example, a floating point number might approximate the value of pi with a sequence of digits such as <code>&quot;3.141592653589793…&quot;</code> up to the maximum size allowed by the data type, often 64 bits or 15 decimal digits.</p>
<p>Cedar does not support floating-point numbers. The reason is because floating-point numbers, by their nature, are  imprecise, and imprecision is not a desirable property of an authorization system. To illustrate this point, consider the following test: 0.1 + 0.2 == 0.3. This appears that it should evaluate to true. But, in most programming languages, it doesn't. <a href="https://0.30000000000000004.com/">This blog post</a> documents the result of the operation in a variety of different programming languages. The reason this occurs is because fractions such as <code>1/10</code> and <code>1/20</code> do not have a precise binary representation. Floating-point arithmetic approximates these values with a limited degree of precision.</p>
<p>Floating-point can lead to other quirks as well. For example <code>262144.0 + 0.01 = 262144.0</code>. One number plus another number equals the same number. You can see a similar effect in Javascript by taking the number 16128500101100052000 and adding 1; you get the same number back. (Javascript number are always 64-bit floating-point). This behavior occurs when adding large and small numbers. An <a href="https://jvns.ca/blog/2023/01/13/examples-of-floating-point-problems/">excellent blog post</a> describes these quirks of floating-point and real world impacts. </p>
<p>Floating-point is a well-defined and a very useful format in many other programming contexts. We elected not to include it in Cedar not because it’s a “bad” format, but because we think it’s a bad idea to use this kind of arithmetic for authorization decisions.</p>
<p>Because of this, Cedar also does not include mathematical operators such as division that return floating-point values. For example, the operation <code>1 / 3</code> would necessitate a floating-point value for the result. Cedar also does not allow multiplication with Decimal types, such as <code>1 * decimal(&quot;0.3&quot;)</code>, as this would lead to the same outcome.</p>
<p>For additional information on the Cedar <code>Decimal</code> type and other operators, see the <a href="https://docs.cedarpolicy.com/syntax-operators.html">documentation</a>. <code>Decimal</code> supports the following operations:</p>
<pre><code>decimal(&quot;0.3&quot;) == decimal(&quot;0.3&quot;)                //true
decimal(&quot;0.3&quot;) != decimal(&quot;0.4321&quot;)             //true
decimal(&quot;0.3&quot;).lessThan(&quot;922337203685477.5807&quot;) //true
decimal(&quot;0.3&quot;).lessThanOrEqual(&quot;0.300&quot;)         //true
decimal(&quot;0.3&quot;).greaterThan(&quot;-4.82&quot;)             //true
decimal(&quot;0.3&quot;).greaterThanOrEqual(&quot;00.30&quot;)      //true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="why-does-cedar-ignore-policies-that-error"><a class="header" href="#why-does-cedar-ignore-policies-that-error">Why does Cedar ignore policies that error?</a></h2>
<p>When asking Cedar to make an authorization decision, it is possible for an error to occur. Consider the following example:</p>
<pre><code>permit (
    principal,
    action == Action::&quot;read&quot;,
    resource in Folder::&quot;financial_reports&quot;
) when {
    principal.jobRole == &quot;Finance&quot;
};
</code></pre>
<p>If the value of <code>principal.jobRole</code> is undefined, this will cause an error during evaluation and Cedar will ignore the policy, treating the situation as if the policy never existed. Cedar will then continue evaluating the other policies to make a final authorization decision. Other situations can cause errors, as well, and they can be found by searching for &quot;error&quot; in the <a href="https://docs.cedarpolicy.com/syntax-operators.html">Cedar operator documentation</a>.</p>
<p>This behavior can lead to the questions:</p>
<ol>
<li>Why does Cedar generate an error?</li>
<li>And, why does it ignore a policy if it errors?</li>
</ol>
<h3 id="why-does-cedar-generate-an-error"><a class="header" href="#why-does-cedar-generate-an-error">Why does Cedar generate an error?</a></h3>
<p>The decision to generate an error may appear unnecessary at first, especially if there are multiple conditions as in the following example:</p>
<pre><code>permit (
    principal,
    action == Action::&quot;read&quot;,
    resource in Folder::&quot;financial_reports&quot;
) when {
    principal.jobRole == &quot;Finance&quot; ||
    principal.jobLevel &gt; 10    
};
</code></pre>
<p>In this example, if <code>principal.jobRole</code> was undefined but <code>principal.jobLevel</code> was defined, it would be convenient for the policy to not error. The second condition would match and everything would proceed happily.</p>
<p>Implementing this behavior would require treating the undefined attribute as some type of <code>nil</code> value. Any operation on this value, such as an equality check, would evaluate to false. This could be done, but it has a side-effect when negations are introduced:</p>
<pre><code>// Permit anyone to read the folder UNLESS their job role is &quot;external_contractor&quot;.
permit (
    principal,
    action == Action::&quot;read&quot;,
    resource in Folder::&quot;financial_reports&quot;
) when {
    !( principal.jobRole == &quot;external_contractor&quot;)
};
</code></pre>
<p>In this example, if a missing value of <code>principal.jobRole</code> was treated as a <code>nil</code> type, then the expression would surprisingly permit access. This is because <code>nil == &quot;external_contractor&quot;</code> would evaluate to false. But, since this is negated, the false becomes true.</p>
<p>As a result, anyone with an undefined value of <code>jobRole</code> gets access to the resource. Is this desired behavior? Is it undesired? The answer is indeterminate and therefore Cedar errors. Only the policy author can resolve the ambiguity. If the author had used the <a href="https://docs.cedarpolicy.com/validation.html">Cedar validator</a>, this policy would have been flagged as a potential error. To fix the error, the policy author can amend the conditions to test if the optional attribute exists before using it.</p>
<pre><code>// Permit anyone to read the folder UNLESS their job role is &quot;external_contractor&quot;.
permit (
    principal,
    action == Action::&quot;read&quot;,
    resource in Folder::&quot;financial_reports&quot;
) when {
    principal has robRole &amp;&amp;
    !( principal.jobRole == &quot;external_contractor&quot;)
};
</code></pre>
<h3 id="why-does-cedar-ignore-policies-that-error-1"><a class="header" href="#why-does-cedar-ignore-policies-that-error-1">Why does Cedar ignore policies that error?</a></h3>
<p>When a policy errors, Cedar could halt and default the authorization decision to <code>Deny</code> instead of ignoring the error and proceeding to evaluate other policies. The reason it doesn't halt is for the safety of applications using Cedar. Imagine a system with 100 policies that are running successfully, and then someone adds policy number 101 which contains an error. If Cedar halted on error and emitted a default-deny decision for the entire batch of policies, then 100% of all authorization decisions in the system could begin failing, simply because someone introduced an error in one new policy.</p>
<p>If ignore-on-error behavior is worrisome to you, note that the Cedar evaluator returns diagnostics that indicate if any policies emitted errors. System owners may use this field to monitor for errors or even choose to fail-closed on error, if desired.</p>
<h3 id="what-about-forbid-statements"><a class="header" href="#what-about-forbid-statements">What about forbid statements?</a></h3>
<p>It is relatively safe to ignore <code>permit</code> statements that error since the impact is to allow less access; something that was intended to be permitted is not permitted. However, the inverse happens when ignoring a <code>forbid</code> statement; something that was intended to be forbidden may not be forbidden.</p>
<p>One of the larger debates during Cedar's design was whether errors in <code>forbid</code> statements should result in a policy being skipped, same as <code>permit</code> statements. The arguments on one side say it feels safer from a security perspective to behave differently and return a Deny decision when a <code>forbid</code> statement emits an error. At the same time, this has to be weighed against the blast impact of a mistake in a single policy resulting in 100% of all authorization queries returning a <code>Deny</code> decision. This behavior could lead to 100% unavailability for an application, which is also a goal of many types of attacks.</p>
<p>In the end, this was a debate with no winning side. The reality is that <code>forbid</code> statements are powerful, and anyone deploying <code>forbid</code> statements to production with zero testing beforehand is likely to have a bad day either way. As a result, Cedar behaves consistently - an error in any policy statement, whether <code>permit</code> or <code>forbid</code>, will result in the policy being skipped during an authorization evaluation. To minimize risk, Cedar policy validation can detect policy statements that may error at runtime so they may be corrected before being used in production. In addition, some authorization systems go further by allowing shadow testing of new policies to audit for unexpected behaviors prior to enforcement. On top of this, Cedar returns diagnostics in the authorization response that indicates if errors occurred. This can be used to monitor for new errors that may arise after a policy is deployed. Or, if desired, system owners may use these diagnostics to observe when an error occurred in a <code>forbid</code> statement and can elect to treat that as a fail-closed scenario, if appropriate for their application.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="why-do-cedar-policies-end-with-a-semi-colon"><a class="header" href="#why-do-cedar-policies-end-with-a-semi-colon">Why do Cedar policies end with a semi-colon?</a></h2>
<p>At one time or another, we all forget to include the semi-colon at the end of a policy statement. This can lead to the question: <em>why is it there?</em></p>
<pre><code>// Sample Policy
permit (principal, action, resource)
when {
    principal == resource.owner
};
</code></pre>
<p>The semi-colon is not needed for parsing. In fact, early prototypes of Cedar didn't include it. The reason it's there is for safety.  Consider what would happen if the example above was accidentally truncated after the first line and a semi-colon wasn't required.</p>
<pre><code>permit( principal, action, resource)
</code></pre>
<p>In such a scenario, this would be a valid statement. It allows <em>&quot;any principal&quot;</em> to perform <em>&quot;any action&quot;</em> on <em>&quot;any resource&quot;</em>. In other words, the system has failed-open because of a truncation mistake. The semi-colon protects against truncation errors.</p>
<p>Now, you might say this feature needn't be baked into the Cedar grammar. After all, it could be the responsibility of everyone who is storing or transmitting policies to sign them or include a checksum, and to enforce that upon receipt to detect accidental truncation. For anyone concerned about data corruption, those remain helpful practices for any data. But, we wanted to ensure Cedar was safe by default for all audiences. And, it's not hard to imagine situations where a checksum wouldn't help at all, such as a bad copy-and-paste where the end-user forgot to highlight the entire policy and only copied a subset into a UI. The little semi-colon is the safety net to catch such mistakes.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>

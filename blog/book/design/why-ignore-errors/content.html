<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Why does Cedar ignore policies that error? - Cedarland Blog</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../about.html">About</a></li><li class="chapter-item expanded "><a href="../../design/introduction/content.html"><strong aria-hidden="true">1.</strong> Design History</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../design/why-cedar/content.html"><strong aria-hidden="true">1.1.</strong> Why was Cedar created?</a></li><li class="chapter-item expanded "><a href="../../design/why-no-regex/content.html"><strong aria-hidden="true">1.2.</strong> Why doesn't Cedar have regexes and string operators?</a></li><li class="chapter-item expanded "><a href="../../design/why-no-float/content.html"><strong aria-hidden="true">1.3.</strong> Why doesn't Cedar support floating point numbers?</a></li><li class="chapter-item expanded "><a href="../../design/why-no-entity-wildcards/content.html"><strong aria-hidden="true">1.4.</strong> Why doesn't Cedar allow wildcards in Entity Ids?</a></li><li class="chapter-item expanded "><a href="../../design/why-ignore-errors/content.html" class="active"><strong aria-hidden="true">1.5.</strong> Why does Cedar ignore policies that error?</a></li><li class="chapter-item expanded "><a href="../../design/why-semicolon/content.html"><strong aria-hidden="true">1.6.</strong> Why do Cedar policies end with a semi-colon?</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cedarland Blog</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="why-does-cedar-ignore-policies-that-error"><a class="header" href="#why-does-cedar-ignore-policies-that-error">Why does Cedar ignore policies that error?</a></h2>
<p>When asking Cedar to make an authorization decision, it is possible for an error to occur. Consider the following example:</p>
<pre><code>permit (
    principal,
    action == Action::&quot;read&quot;,
    resource in Folder::&quot;financial_reports&quot;
) when {
    principal.jobRole == &quot;Finance&quot;
};
</code></pre>
<p>If the value of <code>principal.jobRole</code> is undefined, this will cause an error during evaluation and Cedar will ignore the policy, treating the situation as if the policy never existed. Cedar will then continue evaluating the other policies to make a final authorization decision. Other situations can cause errors, as well, and they can be found by searching for &quot;error&quot; in the <a href="https://docs.cedarpolicy.com/syntax-operators.html">Cedar operator documentation</a>.</p>
<p>This behavior can lead to the questions:</p>
<ol>
<li>Why does Cedar generate an error?</li>
<li>And, why does it ignore a policy if it errors?</li>
</ol>
<h3 id="why-does-cedar-generate-an-error"><a class="header" href="#why-does-cedar-generate-an-error">Why does Cedar generate an error?</a></h3>
<p>The decision to generate an error may appear unnecessary at first, especially if there are multiple conditions as in the following example:</p>
<pre><code>permit (
    principal,
    action == Action::&quot;read&quot;,
    resource in Folder::&quot;financial_reports&quot;
) when {
    principal.jobRole == &quot;Finance&quot; ||
    principal.jobLevel &gt; 10    
};
</code></pre>
<p>In this example, if <code>principal.jobRole</code> was undefined but <code>principal.jobLevel</code> was defined, it would be convenient for the policy to not error. The second condition would match and everything would proceed happily.</p>
<p>Implementing this behavior would require treating the undefined attribute as some type of <code>nil</code> value. Any operation on this value, such as an equality check, would evaluate to false. This could be done, but it has a side-effect when negations are introduced:</p>
<pre><code>// Permit anyone to read the folder UNLESS their job role is &quot;external_contractor&quot;.
permit (
    principal,
    action == Action::&quot;read&quot;,
    resource in Folder::&quot;financial_reports&quot;
) when {
    !( principal.jobRole == &quot;external_contractor&quot;)
};
</code></pre>
<p>In this example, if a missing value of <code>principal.jobRole</code> was treated as a <code>nil</code> type, then the expression would surprisingly permit access. This is because <code>nil == &quot;external_contractor&quot;</code> would evaluate to false. But, since this is negated, the false becomes true.</p>
<p>As a result, anyone with an undefined value of <code>jobRole</code> gets access to the resource. Is this desired behavior? Is it undesired? The answer is indeterminate and therefore Cedar errors. Only the policy author can resolve the ambiguity. If the author had used the <a href="https://docs.cedarpolicy.com/validation.html">Cedar validator</a>, this policy would have been flagged as a potential error. To fix the error, the policy author can amend the conditions to test if the optional attribute exists before using it.</p>
<pre><code>// Permit anyone to read the folder UNLESS their job role is &quot;external_contractor&quot;.
permit (
    principal,
    action == Action::&quot;read&quot;,
    resource in Folder::&quot;financial_reports&quot;
) when {
    principal has robRole &amp;&amp;
    !( principal.jobRole == &quot;external_contractor&quot;)
};
</code></pre>
<h3 id="why-does-cedar-ignore-policies-that-error-1"><a class="header" href="#why-does-cedar-ignore-policies-that-error-1">Why does Cedar ignore policies that error?</a></h3>
<p>When a policy errors, Cedar could halt and default the authorization decision to <code>Deny</code> instead of ignoring the error and proceeding to evaluate other policies. The reason it doesn't halt is for the safety of applications using Cedar. Imagine a system with 100 policies that are running successfully, and then someone adds policy number 101 which contains an error. If Cedar halted on error and emitted a default-deny decision for the entire batch of policies, then 100% of all authorization decisions in the system could begin failing, simply because someone introduced an error in one new policy.</p>
<p>If ignore-on-error behavior is worrisome to you, note that the Cedar evaluator returns diagnostics that indicate if any policies emitted errors. System owners may use this field to monitor for errors or even choose to fail-closed on error, if desired.</p>
<h3 id="what-about-forbid-statements"><a class="header" href="#what-about-forbid-statements">What about forbid statements?</a></h3>
<p>It is relatively safe to ignore <code>permit</code> statements that error since the impact is to allow less access; something that was intended to be permitted is not permitted. However, the inverse happens when ignoring a <code>forbid</code> statement; something that was intended to be forbidden may not be forbidden.</p>
<p>One of the larger debates during Cedar's design was whether errors in <code>forbid</code> statements should result in a policy being skipped, same as <code>permit</code> statements. The arguments on one side say it feels safer from a security perspective to behave differently and return a Deny decision when a <code>forbid</code> statement emits an error. At the same time, this has to be weighed against the blast impact of a mistake in a single policy resulting in 100% of all authorization queries returning a <code>Deny</code> decision. This behavior could lead to 100% unavailability for an application, which is also a goal of many types of attacks.</p>
<p>In the end, this was a debate with no winning side. The reality is that <code>forbid</code> statements are powerful, and anyone deploying <code>forbid</code> statements to production with zero testing beforehand is likely to have a bad day either way. As a result, Cedar behaves consistently - an error in any policy statement, whether <code>permit</code> or <code>forbid</code>, will result in the policy being skipped during an authorization evaluation. To minimize risk, Cedar policy validation can detect policy statements that may error at runtime so they may be corrected before being used in production. In addition, some authorization systems go further by allowing shadow testing of new policies to audit for unexpected behaviors prior to enforcement. On top of this, Cedar returns diagnostics in the authorization response that indicates if errors occurred. This can be used to monitor for new errors that may arise after a policy is deployed. Or, if desired, system owners may use these diagnostics to observe when an error occurred in a <code>forbid</code> statement and can elect to treat that as a fail-closed scenario, if appropriate for their application.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../design/why-no-entity-wildcards/content.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../design/why-semicolon/content.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../design/why-no-entity-wildcards/content.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../design/why-semicolon/content.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
